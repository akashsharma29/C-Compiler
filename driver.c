/**********************
Batch number 39
SAMISH BEDI 
2012B3A7735P
AKASH SHARMA
2012B2A7771P
**********************/


#include<stdio.h>
#include<string.h>
#include<stdlib.h>
#include "parser.h"
#include "lexer.h"
#include "ast.h"
#include "parser.h"
#include "symbolTable.h"
#include "codegen.h"


int main(int argc,char *argv[]){
    if(argc<3){
        printf("Too few arguments\n");
        return -1;
    }else if(argc>3){
        printf("Too many arguments\n");
        return -1;
    }
    

    parseTree *t;

    printf("\n******************\nBATCH 39\nSAMISH BEDI\n2012B3A7735P\nAKASH SHARMA\n2012B2A7771P\n******************\n\nImportant Information:\n");
   
    printf("LEVEL 4:  Symbol table/ AST/ Semantic Rules modules work.\n\n");
    printf("//Symbol Table is implemented and working\n//Semantic and type checking is done\n//AST construction completed\n//Code generation implemented (except for arithmetic operations on records e.g., main4.txt)\n//NASM command: nasm -felf6codegen.asm && gcc codegen.o && ./a.out\n\n\n");
    
    int ans;
   
    int exit=0;

    printf("\nPress option for the defined task:\n\n1 :  for printing the token list generated by the lexer (on the console)\n2 :  for parsing to verify the syntactic correctness of the input source code and to produce parse tree (On Console)\n3 :  for printing the Abstract Syntax Tree in depth first order in appropriate format. (On Console)\n4 :  for displaying the amount of allocated memory and number of nodes to each of parse tree and abstract syntax tree for the test case used.\n5 :  for  printing the Symbol Table\n6 :  for compiling to verify the syntactic and semantic correctness of the input source code \n7 :  for producing assembly code\n\n\n");
    scanf("%d",&ans);
    printf("\n\n");
    switch(ans){
              
        case 1:{
        	printf("\n\n**********TOKEN LIST:****************\n\n");
            printTokens(argv[1]);
            break;
        }
        
        case 2:{
        	printf("\n\n**********PARSE TREE:****************\n\n");
            parser_main();
            t=parseInputSourceCode(argv[1]);
            if(t!=NULL){


            
            printParseTree(t);
            printf("\n");
            fclose(F);
            printf("\n\nCode is syntactically incorrect.\n\n");
            }else{
                printf("\nParse tree cannot be formed. Code is syntactically incorrect.\n");
            }

                break;
        }
        
        case 3:{
            parser_main();
            t=parseInputSourceCode(argv[1]);
            if(t!=NULL){
		        constructAST(t);
		        printf("\n\n**********AST:****************\n\n");
		        printf("\nAST is:\n");
   printf("%-20s%-20s%-20s%-20s%-20s%-20s%-20s\n","lexemeCurrentNode","lineno","token","valueIfNumber","parentNodeSymbol","isLeafNode(yes/no)","NodeSymbol");
		        printAST(t->root);
		    }
            break;
            }
        
        case 4:{
        	parser_main();
            t=parseInputSourceCode(argv[1]);
            if(t!=NULL){
			pstcount=0;
			countPST(t->root);	
		    constructAST(t);			
			astcount=0;
            countAST(t->root);
          	printf("\n\n**********COMPRESSION PERCENTAGE:****************\n\n");
			printf("Parse tree   Number of Nodes=%d   Allocated Memory=%d\n",pstcount,(int)sizeof(treeNode)*pstcount);
			printf("AST          Number of Nodes=%d   Allocated Memory=%d\n",astcount,(int)sizeof(treeNode)*astcount);
			
			double cp=(pstcount*1.0-astcount*1.0)/pstcount*100.0;
			
			printf("Compression Percentage= %.2lf%c\n",cp,37);
		        }else{
            	printf("\n\nCode is syntactically incorrect.\n\n");
            }
		
		break;
           
        }
        
        case 5:{
           parser_main();
            t=parseInputSourceCode(argv[1]);
            
            //symbol table
            if(t!=NULL){
            constructAST(t);
            ST_main(t);
            printf("\n\n%-30s %-30s %-30s %-30s\n","Lexeme","type","scope","offset");
            printf("%-30s %-30s %-30s %-30s\n","------","----","-----","------");
            printST(globalTable);
            }else{
            	printf("\n\nCode is syntactically incorrect.\n\n");
            }
            break;
			
        }

		case 6:{
			parser_main();
            t=parseInputSourceCode(argv[1]);
            if(t!=NULL){
		        constructAST(t);
		        //printAST(t->root);
            	ST_main(t);
            	if(error_flag==0){
            	printf("\n\nCode compiles successfully.\n\n");
            
		        }else{
					printf("\n\nCode is semantically incorrect.\n\n");            
		        }
            }else{
            	printf("\n\nCode is syntactically incorrect.\n\n");
            }
            
            
            break;
		}
        
    
	case 7:{
		parser_main();
            t=parseInputSourceCode(argv[1]);
            if(t!=NULL){
		        constructAST(t);
            	ST_main(t);
            	
            	if(error_flag==0){
            	codegen_main(t);
            	printf("\n\nCode compiles successfully. ASM file generated\n\n");
            	
		        }else{
					printf("\n\nCode is semantically incorrect.\n\n");            
		        }
            }else{
            	printf("\n\nCode is syntactically incorrect.\n\n");
            }
            
            
            break;
		}


	
        
        default:
            break;
    
        }
    
    
    return 0;
    
}
